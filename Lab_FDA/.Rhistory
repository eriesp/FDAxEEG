legend('topright', c("Bias","Var","MSE"), col=c("black","red","green"),
lty=1, cex=.5)
breaks <- abscissa[((0:50)*2)+1]
basis <- create.bspline.basis(breaks, norder=m)
functionalPar <- fdPar(fdobj=basis, Lfdobj=3, lambda=1e-8)  # I want to penaliza the third derivative
Xss <- smooth.basis(abscissa, Xobs0, functionalPar)
Xss0 <- eval.fd(abscissa, Xss$fd, Lfd=0)
Xss1 <- eval.fd(abscissa, Xss$fd, Lfd=1)
Xss2 <- eval.fd(abscissa, Xss$fd, Lfd=2)
functionalPar
Xss
df <- Xss$df   #  the degrees of freedom in the smoothing curve
df
gcv <- Xss$gcv  #  the value of the gcv statistic
gcv
par(mfrow=c(2,2),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xss0 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(abscissa,Xss1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
points(abscissa,Xss2 ,type="l",col="blue",lwd=2)
plot(basis)
# change lambda: 1e-5
functionalParbis <- fdPar(fdobj=basis, Lfdobj=3, lambda=1e-5)
Xssbis <- smooth.basis(abscissa, Xobs0, functionalParbis)
Xss0bis <- eval.fd(abscissa, Xssbis$fd, Lfd=0)
Xss1bis <- eval.fd(abscissa, Xssbis$fd, Lfd=1)
Xss2bis <- eval.fd(abscissa, Xssbis$fd, Lfd=2)
dfbis <- Xssbis$df   #  the degrees of freedom in the smoothing curve
dfbis
gcvbis <- Xssbis$gcv  #  the value of the gcv statistic
gcvbis
# change lambda: 1e-12    (very small)
functionalParter <- fdPar(fdobj=basis, Lfdobj=3, lambda=1e-12)
Xsster <- smooth.basis(abscissa, Xobs0, functionalParter)
Xss0ter <- eval.fd(abscissa, Xsster$fd, Lfd=0)
Xss1ter <- eval.fd(abscissa, Xsster$fd, Lfd=1)
Xss2ter <- eval.fd(abscissa, Xsster$fd, Lfd=2)
dfter <- Xsster$df   #  the degrees of freedom in the smoothing curve
dfter
gcvter <- Xsster$gcv  #  the value of the gcv statistic
gcvter
par(mfrow=c(2,2),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
par(mfrow=c(2,2),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xss0ter ,type="l",col="red",lwd=2)
points(abscissa,Xss0bis ,type="l",col="green",lwd=2)
points(abscissa,Xss0 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(abscissa,Xss1ter ,type="l",col="red",lwd=2)
points(abscissa,Xss1bis ,type="l",col="green",lwd=2)
points(abscissa,Xss1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
points(abscissa,Xss2ter ,type="l",col="red",lwd=2)
points(abscissa,Xss2bis ,type="l",col="green",lwd=2)
points(abscissa,Xss2 ,type="l",col="blue",lwd=2)
lambda <- c(1e-6,1e-7,1e-8,1e-9,1e-10,1e-11,1e-12)
gcv <- numeric(length(lambda))
for (i in 1:length(lambda)){
functionalPar <- fdPar(fdobj=basis, Lfdobj=3, lambda=lambda[i])
gcv[i] <- smooth.basis(abscissa, Xobs0, functionalPar)$gcv
}
par(mfrow=c(1,1))
plot(log10(lambda),gcv)
lambda[which.min(gcv)]
library(KernSmooth)
help(locpoly)
m <- 5           # order of the polynomial
degree <- m-1    # degree of the polynomial
bw <- 0.05 # bandwidth
Xsm0 <- locpoly(abscissa, Xobs0, degree=degree,
bandwidth=bw, gridsize=length(abscissa),
range.x=range(abscissa))
Xsm0 <- Xsm0$y
par(mfrow=c(1,1))
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsm0 ,type="l",col="blue")
Xsm1 <- locpoly(abscissa,Xobs0,drv=1,degree=degree,bandwidth=bw,
gridsize=length(abscissa), range.x=range(abscissa))
Xsm1 <- Xsm1$y
Xsm2 <- locpoly(abscissa,Xobs0,drv=2,degree=degree,bandwidth=bw,
gridsize=length(abscissa), range.x=range(abscissa))
Xsm2 <- Xsm2$y
par(mfrow=c(2,2),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsm0 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(abscissa,Xsm1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
points(abscissa,Xsm2 ,type="l",col="blue",lwd=2)
bw <- 0.15
Xsm0bis <- locpoly(abscissa,Xobs0,drv=0,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Xsm0bis <- Xsm0bis$y
Xsm1bis <- locpoly(abscissa,Xobs0,drv=1,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Xsm1bis <- Xsm1bis$y
Xsm2bis <- locpoly(abscissa,Xobs0,drv=2,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Xsm2bis <- Xsm2bis$y
par(mfrow=c(2,2),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsm0bis ,type="l",col="green",lwd=2)
points(abscissa,Xsm0 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(abscissa,Xsm1bis ,type="l",col="green",lwd=2)
points(abscissa,Xsm1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
points(abscissa,Xsm2bis ,type="l",col="green",lwd=2)
points(abscissa,Xsm2 ,type="l",col="blue",lwd=2)
bw <- 0.015
Xsm0ter <- locpoly(abscissa,Xobs0,drv=0,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Xsm0ter <- Xsm0ter$y
Xsm1ter <- locpoly(abscissa,Xobs0,drv=1,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Xsm1ter <- Xsm1ter$y
Xsm2ter <- locpoly(abscissa,Xobs0,drv=2,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Xsm2ter <- Xsm2ter$y
par(mfrow=c(2,2),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
points(abscissa,Xsm0ter ,type="l",col="red",lwd=2)
points(abscissa,Xsm0bis ,type="l",col="green",lwd=2)
points(abscissa,Xsm0 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX1,xlab="t",ylab="first differences x",type="l")
points(abscissa,Xsm1ter ,type="l",col="red",lwd=2)
points(abscissa,Xsm1bis ,type="l",col="green",lwd=2)
points(abscissa,Xsm1 ,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="t",ylab="second differences x",type="l")
points(abscissa,Xsm2ter ,type="l",col="red",lwd=2)
points(abscissa,Xsm2bis ,type="l",col="green",lwd=2)
points(abscissa,Xsm2 ,type="l",col="blue",lwd=2)
age <- growth$age
heightbasis12 <- create.bspline.basis(rangeval = c(1,18), nbasis = 12, norder = 6)
basismat <- eval.basis(evalarg = growth$age, basisobj = heightbasis12)
heightmat <- growth$hgtf
heightcoef <- lsfit(x = basismat, y = heightmat, intercept=FALSE)$coef
height <- basismat %*% lsfit(basismat, heightmat, intercept=FALSE)$coef
basismat1 <- eval.basis(evalarg = growth$age, basisobj = heightbasis12,
Lfdobj=1)
heightvelocity <- basismat1 %*% lsfit(x = basismat, y = heightmat,
intercept=FALSE)$coef
basismat2 <- eval.basis(evalarg = growth$age, basisobj = heightbasis12,Lfdobj=2)
heightacceleration <- basismat2 %*% lsfit(x=basismat, y= heightmat, intercept=FALSE)$coef
par(mfrow=c(2,2),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
matplot(age,height,type="l" )
matplot(age,heightvelocity,type="l" )
abline(h=0)
matplot(age,heightacceleration,type="l")
par(mfrow=c(2,2),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
matplot(age,height,type="l" )
matplot(age[-c(1,2,3,31)],heightvelocity[-c(1,2,3,31),],type="l" )
abline(h=0)
matplot(age[-c(1,2,3,31)],heightacceleration[-c(1,2,3,31),],type="l")
nage <- length(age)
ageRng <- range(age)
nfine <- 101
agefine <- seq(ageRng[1], ageRng[2], length=nfine)
hgtf <- growth$hgtf[,1:5]
ncasef <- dim(hgtf)[2]
hgtf
norder <- 6
nbasis <- nage - 2 + norder
wbasis <- create.bspline.basis(rangeval = ageRng, nbasis = nbasis,
norder = norder, breaks = age)
Lfdobj <- 3
lambda <- 10^(-0.5)
cvecf <- matrix(0, nbasis, ncasef) # this is used as initial value
# for the numerical techniques
Wfd0 <- fd(coef = cvecf, basisobj = wbasis)
growfdPar <- fdPar(fdobj = Wfd0, Lfdobj = Lfdobj, lambda = lambda)
# We carry out a monotone smoothing
help(smooth.monotone)
growthMon <- smooth.monotone(argvals = age, y = hgtf, WfdParobj = growfdPar)
Wfd <- growthMon$Wfd
betaf <- growthMon$beta
hgtfhatfd <- growthMon$yhatfd
velocfdUN <- deriv.fd(expr = hgtfhatfd, Lfdobj = 1)
velocmeanfdUN <- mean.fd(velocfdUN)
accelfdUN <- deriv.fd(expr = hgtfhatfd, Lfdobj = 2)
accelmeanfdUN <- mean.fd(accelfdUN)
par(mfrow=c(2,2),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
plot(hgtfhatfd, xlim=c(1,18), lty=1, lwd=2,
cex=2, xlab="Age", ylab="Growth (cm)")
plot(velocfdUN, xlim=c(1,18),  lty=1, lwd=2,
cex=2, xlab="Age", ylab="Velocity (cm/yr)")
plot(accelfdUN, xlim=c(1,18), ylim=c(-4,3), lty=1, lwd=2,
cex=2, xlab="Age", ylab="Acceleration (cm/yr/yr)")
plot(wbasis)
noisycurve3D <- read.table("noisycurve3D.txt",header=T)
Xobs0 <- noisycurve3D$X0
Yobs0 <- noisycurve3D$Y0
Zobs0 <- noisycurve3D$Z0
obs0 <- rbind(Xobs0,Yobs0,Zobs0)
abscissa <- noisycurve3D$Abscissa
NT <- length(abscissa)
truecurve3D <- read.table("truecurve3D.txt",header=T)
Xtrue0 <- truecurve3D$X0
Ytrue0 <- truecurve3D$Y0
Ztrue0 <- truecurve3D$Z0
true0 <- rbind(Xtrue0,Ytrue0,Ztrue0)
library(rgl)
open3d()
lines3d(t(true0[1,]),t(true0[2,]),t(true0[3,]),xlab="",ylab="",zlab="",size=3,axes=F)
points3d(t(obs0[1,]),t(obs0[2,]),t(obs0[3,]),xlab="",ylab="",zlab="",size=2,axes=F,pch=19,cex=2)
box3d()
rappincX1 <- (Xobs0[3:NT]-Xobs0[1:(NT-2)])/(abscissa[3:NT]-abscissa[1:(NT-2)])
rappincY1 <- (Yobs0[3:NT]-Yobs0[1:(NT-2)])/(abscissa[3:NT]-abscissa[1:(NT-2)])
rappincZ1 <- (Zobs0[3:NT]-Zobs0[1:(NT-2)])/(abscissa[3:NT]-abscissa[1:(NT-2)])
rappincX2 <- ((Xobs0[3:NT]-Xobs0[2:(NT-1)])/(abscissa[3:NT]-abscissa[2:(NT-1)])-(Xobs0[2:(NT-1)]-Xobs0[1:(NT-2)])/(abscissa[2:(NT-1)]-abscissa[1:(NT-2)]))*2/(abscissa[3:(NT)]-abscissa[1:(NT-2)])
rappincY2 <- ((Yobs0[3:NT]-Yobs0[2:(NT-1)])/(abscissa[3:NT]-abscissa[2:(NT-1)])-(Yobs0[2:(NT-1)]-Yobs0[1:(NT-2)])/(abscissa[2:(NT-1)]-abscissa[1:(NT-2)]))*2/(abscissa[3:(NT)]-abscissa[1:(NT-2)])
rappincZ2 <- ((Zobs0[3:NT]-Zobs0[2:(NT-1)])/(abscissa[3:NT]-abscissa[2:(NT-1)])-(Zobs0[2:(NT-1)]-Zobs0[1:(NT-2)])/(abscissa[2:(NT-1)]-abscissa[1:(NT-2)]))*2/(abscissa[3:(NT)]-abscissa[1:(NT-2)])
par(mfrow=c(3,3),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
plot(abscissa,obs0[1,],xlab=expression(tilde(s)),ylab="observed data x",cex=0.1,asp=1)
plot(abscissa,obs0[2,],xlab=expression(tilde(s)),ylab="observed data y",cex=0.1,asp=1)
plot(abscissa,obs0[3,],xlab=expression(tilde(s)),ylab="observed data z",cex=0.1,asp=1)
plot(abscissa[2:(NT-1)],rappincX1,xlab=expression(tilde(s)),ylab="first differences x",type="l",asp=1)
plot(abscissa[2:(NT-1)],rappincY1,xlab=expression(tilde(s)),ylab="first differences y",type="l",asp=1)
plot(abscissa[2:(NT-1)],rappincZ1,xlab=expression(tilde(s)),ylab="first differences z",type="l",asp=1)
plot(abscissa[2:(NT-1)],rappincX2,xlab=expression(tilde(s)),ylab="second differences x",type="l")
plot(abscissa[2:(NT-1)],rappincY2,xlab=expression(tilde(s)),ylab="second differences y",type="l")
plot(abscissa[2:(NT-1)],rappincZ2,xlab=expression(tilde(s)),ylab="second differences z",type="l")
bw <- 0.05
Xsm0 <- locpoly(abscissa,Xobs0,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Xsm0 <- Xsm0$y
Xsm1 <- locpoly(abscissa,Xobs0,drv=1,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Xsm1 <- Xsm1$y
Xsm2 <- locpoly(abscissa,Xobs0,drv=2,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Xsm2 <- Xsm2$y
Ysm0 <- locpoly(abscissa,Yobs0,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Ysm0 <- Ysm0$y
Ysm1 <- locpoly(abscissa,Yobs0,drv=1,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Ysm1 <- Ysm1$y
Ysm2 <- locpoly(abscissa,Yobs0,drv=2,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Ysm2 <- Ysm2$y
Zsm0 <- locpoly(abscissa,Zobs0,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Zsm0 <- Zsm0$y
Zsm1 <- locpoly(abscissa,Zobs0,drv=1,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Zsm1 <- Zsm1$y
Zsm2 <- locpoly(abscissa,Zobs0,drv=2,degree=degree,bandwidth=bw,gridsize=length(abscissa), range.x=range(abscissa))
Zsm2 <- Zsm2$y
par(mfrow=c(3,3),mar=c(6,5,2,1),mex=0.6, mgp=c(2.2,0.7,0),pty="m", font.main=1,font.lab=1, font.axis=1,cex.lab=1.3,cex.axis=1)
plot(abscissa,obs0[1,],xlab="s",ylab="x",cex=0.1,asp=1,xlim=c(0,1))
points(abscissa,Xsm0,type="l",col="blue",lwd=2)
plot(abscissa,obs0[2,],xlab="s",ylab="y",cex=0.1,asp=1,xlim=c(0,1))
points(abscissa,Ysm0,type="l",col="blue",lwd=2)
plot(abscissa,obs0[3,],xlab="s",ylab="z",cex=0.1,asp=1,xlim=c(0,1))
points(abscissa,Zsm0,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX1,xlab="s",ylab="x'",type="l",ylim=c(-0.5,0.5),xlim=c(0,1))
points(abscissa,Xsm1,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincY1,xlab="s",ylab="y'",type="l",ylim=c(-0.5,0.5),xlim=c(0,1))
points(abscissa,Ysm1,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincZ1,xlab="s",ylab="z'",type="l",ylim=c(-0.5,0.5),xlim=c(0,1))
points(abscissa,Zsm1,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincX2,xlab="s",ylab="x''",type="l")
points(abscissa,Xsm2,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincY2,xlab="s",ylab="y''",type="l")
points(abscissa,Ysm2,type="l",col="blue",lwd=2)
plot(abscissa[2:(NT-1)],rappincZ2,xlab="s",ylab="z''",type="l")
points(abscissa,Zsm2,type="l",col="blue",lwd=2)
open3d()
lines3d(t(true0[1,]),t(true0[2,]),t(true0[3,]),xlab="",ylab="",zlab="",size=3,axes=F)
points3d(t(obs0[1,]),t(obs0[2,]),t(obs0[3,]),size=2,pch=19,cex=2)
lines3d(t(Xsm0),t(Ysm0),t(Zsm0),size=3,col="blue")
box3d()
data_W <- CanadianWeather$dailyAv[,,1]
head(data_W)
dim(data_W)
matplot(data_W,type='l',main='Canadian temperature',xlab='Day',ylab='Temperature')
time <- 1:365
# Choice 1: we set a high dimensional basis (interpolating)
# Pros: no loss of information
# Cons: possible overfitting
basis.1 <- create.fourier.basis(rangeval=c(0,365),nbasis=365)
data_W.fd.1 <- Data2fd(y = data_W,argvals = time,basisobj = basis.1)
plot.fd(data_W.fd.1)
# Choice 2: reduced dimensionality (we set a low dimensional basis)
# Pros: the data are much smoother and the measurement error is filtered
# Cons: I could have lost important information
basis.2 <- create.fourier.basis(rangeval=c(0,365),nbasis=21)
data_W.fd.2 <- Data2fd(y = data_W,argvals = time,basisobj = basis.2)
plot.fd(data_W.fd.2)
# Choice 3: compromise between 1 and 2
basis.3 <- create.fourier.basis(rangeval=c(0,365),nbasis=109)
data_W.fd.3 <- Data2fd(y = data_W,argvals = time,basisobj = basis.3)
plot.fd(data_W.fd.3)
# estimate of the mean and of the covariance kernel
library(fields)
x11(width=10)
par(mfrow=c(2,3))
#mean
plot.fd(data_W.fd.1)
lines(mean.fd(data_W.fd.1),lwd=3)
plot.fd(data_W.fd.2)
lines(mean.fd(data_W.fd.2),lwd=2)
plot.fd(data_W.fd.3)
lines(mean.fd(data_W.fd.3),lwd=2)
# covariance
eval.1 <- eval.fd(time,data_W.fd.1)
image.plot(time,time,(cov(t(eval.1))[1:365,]))
eval.2 <- eval.fd(time,data_W.fd.2)
image.plot(time,time,(cor(t(eval.2))[1:365,]))
eval.3 <- eval.fd(time,data_W.fd.3)
image.plot(time,time,(cov(t(eval.3))[1:365,]))
graphics.off()
data_L <- lip
time <- seq(0,350,by=7)
matplot(time,data_L,type='l',main='Lip data',ylab='Position',
xlab='Time (millisec.)')
basis <- create.fourier.basis(rangeval=c(0,350),nbasis=51)
data_L.fd <- Data2fd(data_L,time,basis)
plot.fd(data_L.fd, main="Fourier")
# Better to use a b-spline basis
basis <- create.bspline.basis(rangeval=c(0,350),nbasis=21)
data_L.fd <- Data2fd(y = data_L,argvals = time,basisobj = basis)
plot.fd(data_L.fd, main="B-splines")
plot.fd(data_L.fd, main="B-splines")
layout(cbind(1,2))
plot.fd(data_L.fd,xaxs='i')
lines(mean.fd(data_L.fd),lwd=2)
eval <- eval.fd(time,data_L.fd)
image.plot(time, time, (cov(t(eval))[1:51,]))
graphics.off()
# interpolated data (Choice 1)
plot.fd(data_W.fd.1,ylab='temperature')
pca_W.1 <- pca.fd(data_W.fd.1,nharm=5,centerfns=TRUE)
# scree plot
# pca.fd computes all the 365 eigenvalues, but only the first
# N-1=34 are non-null
plot(pca_W.1$values[1:35],xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.1$values)[1:35]/sum(pca_W.1$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
# first two FPCs
layout(cbind(1,2))
plot(pca_W.1$harmonics[1,],col=1,ylab='FPC1',ylim=c(-0.1,0.08))
abline(h=0,lty=2)
plot(pca_W.1$harmonics[2,],col=2,ylab='FPC2',ylim=c(-0.1,0.08))
# plot of the FPCs as perturbation of the mean
media <- mean.fd(data_W.fd.1)
plot(media,lwd=2,ylim=c(-25,20),ylab='temperature',main='FPC1')
lines(media+pca_W.1$harmonics[1,]*sqrt(pca_W.1$values[1]), col=2)
lines(media-pca_W.1$harmonics[1,]*sqrt(pca_W.1$values[1]), col=3)
plot(media,lwd=2,ylim=c(-20,20),ylab='temperature',main='FPC2')
lines(media+pca_W.1$harmonics[2,]*sqrt(pca_W.1$values[2]), col=2)
lines(media-pca_W.1$harmonics[2,]*sqrt(pca_W.1$values[2]), col=3)
# temperate climate or not
# Command of the library fda that automatically does these plots
par(mfrow=c(1,1))
plot.pca.fd(pca_W.1, nx=100, pointplot=TRUE, harm=c(1,2), expand=0, cycle=FALSE)
par(mfrow=c(1,2))
plot.pca.fd(pca_W.1, nx=100, pointplot=TRUE, harm=c(1,2), expand=0, cycle=FALSE)
graphics.off()
###
# smooth data (Choice 2)
plot.fd(data_W.fd.2)
pca_W.2 <- pca.fd(data_W.fd.2,nharm=5,centerfns=TRUE)
plot(pca_W.2$values,xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.2$values)/sum(pca_W.2$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
layout(cbind(1,2))
plot(pca_W.2$harmonics[1,],col=1,ylab='FPC1',ylim=c(-0.1,0.08))
abline(h=0,lty=2)
plot(pca_W.2$harmonics[2,],col=2,ylab='FPC2',ylim=c(-0.1,0.08))
# plot of the FPCs as perturbation of the mean
media <- mean.fd(data_W.fd.2)
plot(media,lwd=2,ylim=c(-25,20),ylab='temperature',main='PC1')
lines(media+pca_W.2$harmonics[1,]*sqrt(pca_W.2$values[1]), col=2)
lines(media-pca_W.2$harmonics[1,]*sqrt(pca_W.2$values[1]), col=3)
plot(media,lwd=2,ylim=c(-20,20),ylab='temperature',main='PC2')
lines(media+pca_W.2$harmonics[2,]*sqrt(pca_W.2$values[2]), col=2)
lines(media-pca_W.2$harmonics[2,]*sqrt(pca_W.2$values[2]), col=3)
graphics.off()
par(mfrow=c(1,2))
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
points(pca_W.1$scores[35,1],pca_W.1$scores[35,2],col=2, lwd=4)
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2",xlim=c(-400,250))
text(pca_W.1$scores[,1],pca_W.1$scores[,2],dimnames(data_W)[[2]], cex=1)
layout(1)
matplot(eval.1,type='l')
lines(eval.1[,35],lwd=4, col=2) #temperature profile for Resolute
coord <- CanadianWeather$coordinates
coord[,2] <- -coord[,2]
plot(coord[,2:1],col=0)
text(coord[,2:1],rownames(coord))
graphics.off()
plot.fd(data_L.fd)
pca_L <- pca.fd(data_L.fd,nharm=5,centerfns=TRUE)
# scree plot
plot(pca_L$values,xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_L$values)/sum(pca_L$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
# First three FPCs
layout(cbind(1,2,3))
plot(pca_L$harmonics[1,],col=1,ylab='FPC1',ylim=c(-0.09,0.11))
plot(pca_L$harmonics[2,],col=2,ylab='FPC2',ylim=c(-0.09,0.11))
plot(pca_L$harmonics[3,],col=3,ylab='FPC3',ylim=c(-0.09,0.11))
# plot of the principal components as perturbation of the mean
media <- mean.fd(data_L.fd)
plot(media,lwd=2,ylim=c(-10,12),main='FPC1')
lines(media+pca_L$harmonic[1,]*sqrt(pca_L$values[1]), col=2)
lines(media-pca_L$harmonic[1,]*sqrt(pca_L$values[1]), col=3)
plot(media,lwd=2,ylim=c(-10,12),main='FPC2')
lines(media+pca_L$harmonic[2,]*sqrt(pca_L$values[2]), col=2)
lines(media-pca_L$harmonic[2,]*sqrt(pca_L$values[2]), col=3)
plot(media,lwd=2,ylim=c(-10,12),main='FPC3')
lines(media+pca_L$harmonic[3,]*sqrt(pca_L$values[3]), col=2)
lines(media-pca_L$harmonic[3,]*sqrt(pca_L$values[3]), col=3)
layout(cbind(1,2,3))
plot(pca_L$scores[,1],pca_L$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
points(pca_L$scores[12,1],pca_L$scores[12,2],col=2, lwd=4)
points(pca_L$scores[9,1],pca_L$scores[9,2],col=3, lwd=4)
plot(pca_L$scores[,1],pca_L$scores[,3],xlab="Scores FPC1",ylab="Scores FPC3",lwd=2)
points(pca_L$scores[12,1],pca_L$scores[12,3],col=2, lwd=4)
points(pca_L$scores[9,1],pca_L$scores[9,3],col=3, lwd=4)
plot(pca_L$scores[,2],pca_L$scores[,3],xlab="Scores FPC2",ylab="Scores FPC3",lwd=2)
points(pca_L$scores[12,2],pca_L$scores[12,3],col=2, lwd=4)
points(pca_L$scores[9,2],pca_L$scores[9,3],col=3, lwd=4)
layout(1)
matplot(eval,type='l')
lines(eval[,12],lwd=4, col=2)
lines(eval[,9],lwd=4, col=3)
graphics.off()
# Using the R package fdakma
library(fdakma)     # fatto al poli al MOX
help(kma)
help(kma.data)
data(kma.data)
names(kma.data)
x <- kma.data$x   # abscissas
y0 <- kma.data$y0 # evaluations of original functions
y1 <- kma.data$y1 # evaluations of original functions' first derivatives
# Plot of original functions
matplot(t(x),t(y0), type='l', xlab='x', ylab='orig.func')
title ('Original functions')
# Plot of original function first derivatives
matplot(t(x),t(y1), type='l', xlab='x', ylab='orig.deriv')
title ('Original function first derivatives')
set.seed(4)
fdakma_example_noalign_0der <- kma(
x=x, y0=y0, n.clust = 3,
warping.method = 'NOalignment',
similarity.method = 'd0.pearson',   # similarity computed as the cosine
# between the original curves
# (correlation)
center.method = 'k-means'           # or k-medoits (?)
#,seeds = c(1,11,21) # you can give a little help to the algorithm...
)
kma.show.results(fdakma_example_noalign_0der)
fdakma_example_noalign_0der$labels
set.seed(5)
fdakma_example_noalign_1der <- kma(
x=x, y0=y0, y1=y1, n.clust = 3,
warping.method = 'NOalignment',
similarity.method = 'd1.pearson',   # similarity computed as the cosine
# between the first derivatives
# (correlation)
center.method = 'k-means'
#,seeds = c(1,11,21) # you can give a little help to the algorithm...
)
kma.show.results(fdakma_example_noalign_1der)
fdakma_example_noalign_1der$labels
table(fdakma_example_noalign_0der$labels,
fdakma_example_noalign_1der$labels, dnn=c("0der", "1der"))
set.seed(1)
fdakma_example <- kma(
x=x, y0=y0, y1=y1, n.clust = 2,
warping.method = 'affine',
similarity.method = 'd1.pearson',  # similarity computed as the cosine
# between the first derivatives
# (correlation)
center.method = 'k-means'
#seeds = c(1,21) # you can give a little help to the algorithm...
)
kma.show.results(fdakma_example)
# Labels assigned to each function
fdakma_example$labels
table(fdakma_example_noalign_0der$labels,
fdakma_example$labels,
dnn=c("NOalign_0der_3groups", "Align_1der_2groups"))
# Total shifts and dilations applied to the original
# abscissa to obtain the aligned abscissa
fdakma_example$shift
fdakma_example$dilation
plot(x, type="n", xlim=c(min(x),max(x)), ylim=c(min(x),max(x)+2), xlab="abscissa", ylab="warping")
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
plot(x, type="n", xlim=c(min(x),max(x)), ylim=c(min(x),max(x)+2), xlab="abscissa", ylab="warping")
title("Alignment affinities")
for(i in 1:30)(
abline(a=fdakma_example$shift[i],b=fdakma_example$dilation[i],
col=fdakma_example_noalign_0der$labels[i])
)
# How to choose the number of clusters and the warping method
help(kma.compare)
kma.compare_example <- kma.compare (
x=x, y0=y0, y1=y1, n.clust = 1:3,
warping.method = c('affine'),
similarity.method = 'd1.pearson',
center.method = 'k-means',
seeds = c(1,21,30),
plot.graph=1)
q()
install.packages(c("fda", "fields"))
